<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fortune Cube</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at top, #121212, #1e1e1e 70%);
      overflow: hidden;
      font-family: Arial, Helvetica, sans-serif;
    }
    input[type="color"] {
      position: absolute;
      display: none;
      z-index: 9999;
      width: 48px;
      height: 36px;
      padding: 0;
      border: none;
      background: transparent;
    }
    #hint {
      position: absolute;
      bottom: 16px;
      left: 16px;
      color: #ccc;
      font-size: 13px;
      opacity: 0.8;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <input id="colorPicker" type="color" value="#00ffff">
  <div id="hint">Click a cube face to change its color</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // --- Setup Scene, Camera, Renderer ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.z = 4.2; // back a bit so full cube fits

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Cube ---
    const geometry = new THREE.BoxGeometry(1.6, 1.6, 1.6);
    const materials = Array.from({ length: 6 }, () =>
      new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        metalness: 0.6,
        roughness: 0.25,
      })
    );
    const cube = new THREE.Mesh(geometry, materials);
    scene.add(cube);

    // --- Eyeball (slightly recessed) ---
    const eyeGeometry = new THREE.SphereGeometry(0.22, 32, 32);
    const eyeMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0x333333,
    });
    const eyeball = new THREE.Mesh(eyeGeometry, eyeMat);

    const pupilGeo = new THREE.SphereGeometry(0.07, 16, 16);
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const pupil = new THREE.Mesh(pupilGeo, pupilMat);
    pupil.position.z = 0.12;
    eyeball.add(pupil);

    eyeball.position.z = 0.42; // visible but not poking out
    cube.add(eyeball);

    // --- Lighting ---
    const pointLight = new THREE.PointLight(0xffffff, 1.3);
    pointLight.position.set(3, 3, 6);
    scene.add(pointLight);
    scene.add(new THREE.AmbientLight(0x404040, 0.7));

    // --- Blink animation setup ---
    let blink = 0;
    let blinking = false;
    setInterval(() => { blinking = true; }, 2500);

    // --- Color Picker + Click Detection ---
    const colorInput = document.getElementById("colorPicker");
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let activeFace = -1;

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(cube);

      if (intersects.length > 0) {
        const faceIndex = Math.floor(intersects[0].faceIndex / 2);
        activeFace = faceIndex;
        colorInput.style.left = event.clientX + "px";
        colorInput.style.top = event.clientY + "px";
        colorInput.style.display = "block";
        colorInput.focus();
      } else {
        colorInput.style.display = "none";
        activeFace = -1;
      }
    }

    function applyColor(e) {
      if (activeFace >= 0 && activeFace < materials.length) {
        materials[activeFace].color.set(e.target.value);
      }
    }

    colorInput.addEventListener("input", applyColor);
    colorInput.addEventListener("change", applyColor);
    window.addEventListener("click", onClick);

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;

      if (blinking) {
        blink += 0.25;
        eyeball.scale.y = Math.abs(Math.cos(blink));
        if (blink > Math.PI) {
          blink = 0;
          blinking = false;
          eyeball.scale.y = 1;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // --- Resize handling ---
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
